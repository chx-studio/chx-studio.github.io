# 面向对象

## 接口的意义

规范、扩展、回调

## 抽象类的意义

1. 为其子类提供一个公共的类型
2. 封装子类中的重复内容 
3. 定义抽象方法，子类虽然有不同的实现 但是定义是一致的

## 抽象类和接口区别

1. 默认的方法实现
抽象类可以有默认的方法实现完全是抽象的。接口根本不存在方法的实现

2. 实现
子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。
子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现

3. 构造器
抽象类可以有构造器
接口不能有构造器

3. 与正常Java类的区别
除了你不能实例化抽象类之外，它和普通Java类没有任何区别
接口是完全不同的类型

4. 访问修饰符
抽象方法可以有public、protected和default这些修饰符
接口方法默认修饰符是public。你不可以使用其它修饰符。

5. main方法
抽象方法可以有main方法并且我们可以运行它
接口没有main方法，因此我们不能运行它。

6. 多继承
抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。

7. 速度
它比接口速度要快
接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。

8. 添加新方法
如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。
如果你往接口中添加方法，那么你必须改变实现该接口的类。

## 内部类的作用

1. 内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。
2. 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
3. 创建内部类对象的时刻并不依赖于外围类对象的创建。
4. 内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。
5. 内部类提供了更好的封装，除了该外围类，其他类都不能访问

## 子类能否重写父类的静态方法

不能

子类继承父类后，用相同的静态方法和非静态方法，这时非静态方法覆盖父类中的方法（即方法重写），父类的该静态方法被隐藏（如果对象是父类则调用该隐藏的方法），另外子类可继承父类的静态与非静态方法，至于方法重载我觉得它其中一要素就是在同一类中，不能说父类中的什么方法与子类里的什么方法是方法重载的体现。

## 下面程序能正常运行吗

```java
public class NULL {
    public static void haha(){
        System.out.println("haha");
    }
    
    public static void main(String[] args) {
        ((NULL)null).haha();
    }
}
```

答案：能正常运行。

输出为haha，因为null值可以强制转换为任何java类类型,(String)null也是合法的。但null强制转换后是无效对象，其返回值还是为null，而static方法的调用是和类名绑定的，不借助对象进行访问所以能正确输出。反过来，没有static修饰就只能用对象进行访问，使用null调用对象肯定会报空指针错了。这里和C++很类似。

## 不通过构造函数也能创建对象吗

能

Java创建对象的几种方式（重要）：
1. 用 new 语句创建对象，这是最常见的创建对象的方法。
2. 运用反射手段, 调用 newInstance() 方法。
3. 调用对象的 clone() 方法。
4. 运用反序列化手段，调用 ObjectInputStream 对象的 readObject() 方法。

    (1) 和 (2) 都会明确的显式的调用构造函数
    (3)是在内存上对已有对象的影印，所以不会调用构造函数
    (4)是从文件中还原类的对象，也不会调用构造函数。